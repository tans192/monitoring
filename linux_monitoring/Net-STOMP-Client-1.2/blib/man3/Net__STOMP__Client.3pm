.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::STOMP::Client 3"
.TH Net::STOMP::Client 3 "2011-09-27" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::STOMP::Client \- STOMP object oriented client module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  #
\&  # simple producer
\&  #
\&
\&  use Net::STOMP::Client;
\&
\&  $stomp = Net::STOMP::Client\->new(host => "127.0.0.1", port => 61613);
\&  $stomp\->connect(login => "guest", passcode => "guest");
\&  $stomp\->send(destination => "/queue/test", body => "hello world!");
\&  $stomp\->disconnect();
\&
\&  #
\&  # consumer with client side acknowledgment
\&  #
\&
\&  use Net::STOMP::Client;
\&
\&  $stomp = Net::STOMP::Client\->new(host => "127.0.0.1", port => 61613);
\&  $stomp\->connect(login => "guest", passcode => "guest");
\&  # declare a callback to be called for each received message frame
\&  $stomp\->message_callback(sub {
\&      my($self, $frame) = @_;
\&
\&      $self\->ack(frame => $frame);
\&      printf("received: %s\en", $frame\->body());
\&      return($self);
\&  });
\&  # subscribe to the given queue
\&  $stomp\->subscribe(destination => "/queue/test", ack => "client");
\&  # wait for a specified message frame
\&  $stomp\->wait_for_frames(callback => sub {
\&      my($self, $frame) = @_;
\&
\&      if ($frame\->command() eq "MESSAGE") {
\&          # stop waiting for new frames if body is "quit"
\&          return(1) if $frame\->body() eq "quit";
\&      }
\&      # continue to wait for more frames
\&      return(0);
\&  });
\&  $stomp\->unsubscribe(destination => "/queue/test");
\&  $stomp\->disconnect();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides an object oriented client interface to interact
with servers supporting \s-1STOMP \s0(Streaming Text Orientated Messaging
Protocol). It supports the major features of modern messaging brokers:
\&\s-1SSL,\s0 asynchronous I/O, receipts and transactions.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
The \fInew()\fR method can be used to create a Net::STOMP::Client object that will
later be used to interact with a server. The following attributes are
supported:
.ie n .IP """version""" 4
.el .IP "\f(CWversion\fR" 4
.IX Item "version"
the \s-1STOMP\s0 version to use (string) or versions to use (reference to a
list of strings); this defaults to the list of all supported versions
.ie n .IP """uri""" 4
.el .IP "\f(CWuri\fR" 4
.IX Item "uri"
the Uniform Resource Identifier (\s-1URI\s0) specifying where the \s-1STOMP\s0
service is and how to connect to it, this can be for instance
\&\f(CW\*(C`tcp://msg01:6163\*(C'\fR or something more complex such as
\&\f(CW\*(C`failover:(ssl://msg01:6162,tcp://msg01:6163)\*(C'\fR
.ie n .IP """host""" 4
.el .IP "\f(CWhost\fR" 4
.IX Item "host"
the server name or \s-1IP\s0 address
.ie n .IP """port""" 4
.el .IP "\f(CWport\fR" 4
.IX Item "port"
the port number of the \s-1STOMP\s0 service
.ie n .IP """timeout""" 4
.el .IP "\f(CWtimeout\fR" 4
.IX Item "timeout"
the maximum time (in seconds) for various operations, see the \*(L"\s-1TIMEOUTS\*(R"\s0
section for more information
.ie n .IP """sockopts""" 4
.el .IP "\f(CWsockopts\fR" 4
.IX Item "sockopts"
arbitrary socket options (as a hash reference) that will be passed to
IO::Socket::INET\->\fInew()\fR or IO::Socket::SSL\->\fInew()\fR
.ie n .IP """callbacks""" 4
.el .IP "\f(CWcallbacks\fR" 4
.IX Item "callbacks"
a hash of code references that will be called on each received frame
.ie n .IP """client_heart_beat""" 4
.el .IP "\f(CWclient_heart_beat\fR" 4
.IX Item "client_heart_beat"
the desired client-side heart-beat setting, see the \*(L"HEART-BEATING\*(R"
section for more information
.ie n .IP """server_heart_beat""" 4
.el .IP "\f(CWserver_heart_beat\fR" 4
.IX Item "server_heart_beat"
the desired server-side heart-beat setting, see the \*(L"HEART-BEATING\*(R"
section for more information
.PP
Upon object creation, a \s-1TCP\s0 connection is made to the server but no
data (i.e. \s-1STOMP\s0 frame) is exchanged.
.SH "SSL"
.IX Header "SSL"
When creating an object with Net::STOMP::Client\->\fInew()\fR, if you supply some
socket options (via \f(CW\*(C`sockopts\*(C'\fR) with a name starting with \f(CW\*(C`SSL_\*(C'\fR,
or if you supply a \s-1URI \s0(via \f(CW\*(C`uri\*(C'\fR) with a scheme containg \f(CW\*(C`ssl\*(C'\fR,
IO::Socket::SSL will be used to create the socket instead of
IO::Socket::INET and the communication with the server will then
go through \s-1SSL.\s0
.PP
Here are the most commonly used \s-1SSL\s0 socket options:
.IP "SSL_ca_path" 4
.IX Item "SSL_ca_path"
path to a directory containing several trusted certificates as
separate files as well as an index of the certificates
.IP "SSL_key_file" 4
.IX Item "SSL_key_file"
path of your \s-1RSA\s0 private key
.IP "SSL_cert_file" 4
.IX Item "SSL_cert_file"
path of your certificate
.IP "SSL_passwd_cb" 4
.IX Item "SSL_passwd_cb"
subroutine that should return the password required to decrypt your
private key
.PP
For more information, see IO::Socket::SSL.
.SH "TIMEOUTS"
.IX Header "TIMEOUTS"
By default, when sending \s-1STOMP\s0 frames, the module waits until the
frame indeed has been sent (from the socket point of view). In case
the server is stuck or unusable, the module can therefore hang.
.PP
When creating the Net::STOMP::Client object, you can pass a \f(CW\*(C`timeout\*(C'\fR
attribute to better control how certain operations handle timeouts.
.PP
This attribute should contain a reference to hash with the following
keys:
.IP "connect" 4
.IX Item "connect"
TCP-level timeout that will be given to the underlying
IO::Socket::INET or IO::Socket::SSL object (default: none)
.IP "connected" 4
.IX Item "connected"
timeout used while waiting for the initial \s-1CONNECTED\s0 frame from the
broker (default: 10)
.IP "receive" 4
.IX Item "receive"
timeout used while trying to receive any frame (default: none)
.IP "send" 4
.IX Item "send"
timeout used while trying to send any frame (default: none)
.PP
All values are in seconds. No timeout means wait until the operation
succeeds.
.PP
As a shortcut, the \f(CW\*(C`timeout\*(C'\fR attribute can also be a scalar. In this
case, only the \f(CW\*(C`connect\*(C'\fR and \f(CW\*(C`connected\*(C'\fR operations use this value.
.SH "STOMP METHODS"
.IX Header "STOMP METHODS"
With a Net::STOMP::Client object, the following methods can be used to
interact with the server. They match one-to-one the different commands
that a client frame can hold:
.IP "\fIconnect()\fR" 4
.IX Item "connect()"
connect to server
.IP "\fIdisconnect()\fR" 4
.IX Item "disconnect()"
disconnect from server
.IP "\fIsubscribe()\fR" 4
.IX Item "subscribe()"
subscribe to something
.IP "\fIunsubscribe()\fR" 4
.IX Item "unsubscribe()"
unsubscribe from something
.IP "\fIsend()\fR" 4
.IX Item "send()"
send a message somewhere
.IP "\fIack()\fR" 4
.IX Item "ack()"
acknowledge the reception of a message
.IP "\fInack()\fR" 4
.IX Item "nack()"
acknowledge the rejection of a message
(\s-1STOMP 1.1\s0 only)
.IP "\fIbegin()\fR" 4
.IX Item "begin()"
begin/start a transaction
.IP "\fIcommit()\fR" 4
.IX Item "commit()"
commit a transaction
.IP "\fIabort()\fR" 4
.IX Item "abort()"
abort/rollback a transaction
.PP
All these methods can receive options that will be passed directly as
frame headers. For instance:
.PP
.Vb 4
\&  $stomp\->subscribe(
\&      destination => "/queue/test",
\&      ack         => "client",
\&  );
.Ve
.PP
Some methods also support other options:
.IP "\fIsend()\fR" 4
.IX Item "send()"
\&\f(CW\*(C`body\*(C'\fR or \f(CW\*(C`body_reference\*(C'\fR: holds the body or body reference of the
message to be sent
.IP "\fIack()\fR" 4
.IX Item "ack()"
\&\f(CW\*(C`frame\*(C'\fR: holds the \s-1MESSAGE\s0 frame object to \s-1ACK\s0
.IP "\fInack()\fR" 4
.IX Item "nack()"
\&\f(CW\*(C`frame\*(C'\fR: holds the \s-1MESSAGE\s0 frame object to \s-1NACK\s0
.PP
Finally, all methods support a \f(CW\*(C`timeout\*(C'\fR option that will be given to
the \fIsend_frame()\fR method called internally to send the crafted frame.
.SH "OTHER METHODS"
.IX Header "OTHER METHODS"
In addition to the \s-1STOMP\s0 methods, the following ones are also available:
.IP "new(\s-1OPTIONS\s0)" 4
.IX Item "new(OPTIONS)"
return a new Net::STOMP::Client object
.IP "\fIpeer()\fR" 4
.IX Item "peer()"
return a Net::STOMP::Client::Peer object containing information about
the connected \s-1STOMP\s0 server
.IP "\fIsocket()\fR" 4
.IX Item "socket()"
return the file handle of the socket connecting the client and the server
.IP "\fIsession()\fR" 4
.IX Item "session()"
return the session identifier if connected or the empty string otherwise
.IP "\fIversion()\fR" 4
.IX Item "version()"
return the \s-1STOMP\s0 version that has been negotiated between the client
and the server or undef if the negotiation did not take place yet
.IP "\fIuuid()\fR" 4
.IX Item "uuid()"
return a universal pseudo-unique identifier to be used for instance in
receipts and transactions
.IP "\fIreceipts()\fR" 4
.IX Item "receipts()"
return the list of not-yet-received receipts, see the \*(L"\s-1RECEIPTS\*(R"\s0
section for more information
.IP "\fIwait_for_frames()\fR" 4
.IX Item "wait_for_frames()"
wait for frames coming from the server, see the next section for more
information
.IP "\fIwait_for_receipts()\fR" 4
.IX Item "wait_for_receipts()"
wait for all receipts to be received, using \fIwait_for_frames()\fR underneath
.IP "noop([timeout => \s-1TIMEOUT\s0])" 4
.IX Item "noop([timeout => TIMEOUT])"
send an empty/noop frame i.e. a single newline byte, using
\&\fIsend_frame()\fR underneath
.SH "CALLBACKS"
.IX Header "CALLBACKS"
Since \s-1STOMP\s0 is asynchronous (for instance, \f(CW\*(C`MESSAGE\*(C'\fR frames could be
sent by the server at any time), Net::STOMP::Client uses callbacks to handle
frames. There are in fact two levels of callbacks.
.PP
First, there are per-command callbacks that will be called each time a
frame is handled (via the internal method \fIdispatch_frame()\fR). Net::STOMP::Client
implements default callbacks that should be sufficient for all frames
except \f(CW\*(C`MESSAGE\*(C'\fR frames, which should really be handled by the coder.
These callbacks should return undef on error, something else on success.
.PP
Here is an example with a callback counting the messages received:
.PP
.Vb 2
\&  $stomp\->message_callback(sub {
\&      my($self, $frame) = @_;
\&
\&      $MessageCount++;
\&      return($self);
\&  });
.Ve
.PP
Here are the methods that can be used to get or set these per-command
callbacks:
.IP "connected_callback([\s-1SUBREF\s0])" 4
.IX Item "connected_callback([SUBREF])"
.PD 0
.IP "error_callback([\s-1SUBREF\s0])" 4
.IX Item "error_callback([SUBREF])"
.IP "message_callback([\s-1SUBREF\s0])" 4
.IX Item "message_callback([SUBREF])"
.IP "receipt_callback([\s-1SUBREF\s0])" 4
.IX Item "receipt_callback([SUBREF])"
.PD
.PP
These callbacks are somehow global and it is good practice not to
change them during a session. If you do not need a global message
callback, you can supply the dummy:
.PP
.Vb 1
\&  $stomp\->message_callback(sub { return(1) });
.Ve
.PP
Then, the \fIwait_for_frames()\fR method takes an optional callback argument
holding some code to be called for each received frame, after the
per-command callback has been called. This can be seen as a local
callback, only valid for the call to \fIwait_for_frames()\fR. This callback
must return undef on error, false if more frames are expected or true
if \fIwait_for_frames()\fR can now stop waiting for new frames and return.
.PP
Here are all the options that can be given to \fIwait_for_frames()\fR:
.IP "callback" 4
.IX Item "callback"
code to be called for each received frame (see above)
.IP "timeout" 4
.IX Item "timeout"
time to wait before giving up, undef means wait forever, this is the
default
.IP "once" 4
.IX Item "once"
wait only for one frame, within the given timeout
.PP
The return value of \fIwait_for_frames()\fR can be: undef in case of error,
false if no suitable frame has been received, the received frame if
there is no user callback or the user callback return value otherwise.
.SH "RECEIPTS"
.IX Header "RECEIPTS"
Net::STOMP::Client has built-in support for receipts.
.PP
Each time a frame is sent, its \f(CW\*(C`receipt\*(C'\fR header (if supplied) is
remembered.
.PP
Each time a \f(CW\*(C`RECEIPT\*(C'\fR frame is received from the server, the
corresponding receipt is ticked off.
.PP
The \fIreceipts()\fR method can be used to get the list of outstanding
receipts.
.PP
The \fIwait_for_receipts()\fR method can be used to wait for all missing
receipts.
.PP
Here is sample code to send two messages with receipts and then wait
for both acknowledgments to come back from the server within ten
seconds:
.PP
.Vb 12
\&  $stomp\->send(
\&      destination => "/queue/test1",
\&      body        => "message 1",
\&      receipt     => $stomp\->uuid(),
\&  );
\&  $stomp\->send(
\&      destination => "/queue/test2",
\&      body        => "message 2",
\&      receipt     => $stomp\->uuid(),
\&  );
\&  $stomp\->wait_for_receipts(timeout => 10);
\&  die("Not all receipts received!\en") if $stomp\->receipts();
.Ve
.SH "TRANSACTIONS"
.IX Header "TRANSACTIONS"
Here is an example using transactions:
.PP
.Vb 10
\&  # create a unique transaction id
\&  $tid = $stomp\->uuid();
\&  # begin the transaction
\&  $stomp\->begin(transaction => $tid);
\&  # send two messages as part of this transaction
\&  $stomp\->send(
\&      destination => "/queue/test1",
\&      body        => "message 1",
\&      transaction => $tid,
\&  );
\&  $stomp\->send(
\&      destination => "/queue/test2",
\&      body        => "message 2",
\&      transaction => $tid,
\&  );
\&  # commit the transaction
\&  $stomp\->commit(transaction => $tid);
.Ve
.SH "HEART-BEATING"
.IX Header "HEART-BEATING"
\&\s-1STOMP 1.1\s0 defines how each end of a \s-1STOMP\s0 connection can check if the
other end is alive. To support heart-beating, this module provides the
following methods:
.IP "\fIlast_received()\fR" 4
.IX Item "last_received()"
return the time at which data was last received, i.e. read from the
network socket
.IP "\fIlast_sent()\fR" 4
.IX Item "last_sent()"
return the time at which data was last sent, i.e. written to the
network socket
.IP "\fIclient_heart_beat()\fR" 4
.IX Item "client_heart_beat()"
(after having received the \s-1CONNECTED\s0 frame) return the negotiated
client-side heart-beat setting
.IP "\fIserver_heart_beat()\fR" 4
.IX Item "server_heart_beat()"
(after having received the \s-1CONNECTED\s0 frame) return the negotiated
server-side heart-beat setting
.IP "beat([timeout => \s-1TIMEOUT\s0])" 4
.IX Item "beat([timeout => TIMEOUT])"
send a noop frame (using the \fInoop()\fR method) unless the last sent time
is recent enough with regard to the client heart-beat setting
.PP
For consistency with other Perl modules (for instance Time::HiRes),
time is always expressed as a fractional number of seconds.
.PP
To use heart-beating, the client must specify the desired
\&\f(CW\*(C`client_heart_beat\*(C'\fR and/or \f(CW\*(C`server_heart_beat\*(C'\fR attributes when
invoking the \fInew()\fR method. Then, once the \s-1CONNECTED\s0 frame has been
received, it can get the negotiated values with the methods above.
.PP
To prove that it is alive, the client just needs to call the \fIbeat()\fR
method.
.PP
To check if the server is alive, the client just needs to compare
what is returned by the \fIlast_received()\fR and \fIserver_heart_beat()\fR methods.
.SH "LOW-LEVEL API"
.IX Header "LOW-LEVEL API"
It should be enough to use the high-level \s-1API\s0 and use, for instance,
the \fIsend()\fR method to create a \s-1MESSAGE\s0 frame and send it in one go.
.PP
If you need lower level interaction, you can manipulate frames with
the Net::STOMP::Client::Frame module.
.PP
You can also use:
.ie n .IP "$stomp\->dispatch_frame(\s-1FRAME\s0)" 4
.el .IP "\f(CW$stomp\fR\->dispatch_frame(\s-1FRAME\s0)" 4
.IX Item "$stomp->dispatch_frame(FRAME)"
dispatch one received frame by calling the appropriate callback
.ie n .IP "$stomp\->send_frame(\s-1FRAME, TIMEOUT\s0)" 4
.el .IP "\f(CW$stomp\fR\->send_frame(\s-1FRAME, TIMEOUT\s0)" 4
.IX Item "$stomp->send_frame(FRAME, TIMEOUT)"
try to send the given frame object within the given \s-1TIMEOUT\s0
.ie n .IP "$stomp\->queue_frame(\s-1FRAME\s0)" 4
.el .IP "\f(CW$stomp\fR\->queue_frame(\s-1FRAME\s0)" 4
.IX Item "$stomp->queue_frame(FRAME)"
add the given frame to the outgoing buffer queue
.ie n .IP "$stomp\->send_data(\s-1TIMEOUT\s0)" 4
.el .IP "\f(CW$stomp\fR\->send_data(\s-1TIMEOUT\s0)" 4
.IX Item "$stomp->send_data(TIMEOUT)"
send all the queued data within the given \s-1TIMEOUT\s0
.ie n .IP "$stomp\->receive_frame(\s-1TIMEOUT\s0)" 4
.el .IP "\f(CW$stomp\fR\->receive_frame(\s-1TIMEOUT\s0)" 4
.IX Item "$stomp->receive_frame(TIMEOUT)"
try to receive a frame within the given \s-1TIMEOUT\s0
.ie n .IP "$stomp\->receive_data(\s-1TIMEOUT\s0)" 4
.el .IP "\f(CW$stomp\fR\->receive_data(\s-1TIMEOUT\s0)" 4
.IX Item "$stomp->receive_data(TIMEOUT)"
try to receive data within the given \s-1TIMEOUT,\s0 this data will be
appended to the incoming buffer
.ie n .IP "$stomp\->\fIoutgoing_buffer_length()\fR" 4
.el .IP "\f(CW$stomp\fR\->\fIoutgoing_buffer_length()\fR" 4
.IX Item "$stomp->outgoing_buffer_length()"
return the length (in bytes) of the outgoing buffer
.ie n .IP "$stomp\->\fIincoming_buffer_reference()\fR" 4
.el .IP "\f(CW$stomp\fR\->\fIincoming_buffer_reference()\fR" 4
.IX Item "$stomp->incoming_buffer_reference()"
return a reference to the incoming buffer
.PP
In these methods, the \s-1TIMEOUT\s0 argument can either be \f(CW\*(C`undef\*(C'\fR (meaning
block until it's done) or \f(CW0\fR (meaning do not block at all) or a
positive number (meaning block at most this number of seconds).
.SH "COMPATIBILITY"
.IX Header "COMPATIBILITY"
This module implements the versions
\&\f(CW1.0\fR (see <http://stomp.github.com/stomp\-specification\-1.0.html>) and
\&\f(CW1.1\fR (see <http://stomp.github.com/stomp\-specification\-1.1.html>)
of the protocol as well as well known extensions for \s-1JMS,\s0 ActiveMQ,
Apollo and RabbitMQ.
.PP
It has been successfully tested against ActiveMQ, Apollo, HornetQ and
RabbitMQ brokers.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
IO::Socket::INET,
IO::Socket::SSL,
Net::STOMP::Client::Error,
Net::STOMP::Client::Frame,
Net::STOMP::Client::Peer,
Time::HiRes.
.SH "AUTHOR"
.IX Header "AUTHOR"
Lionel Cons <http://cern.ch/lionel.cons>
.PP
Copyright \s-1CERN 2010\-2011\s0
