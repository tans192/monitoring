.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::STOMP::Client::Frame 3"
.TH Net::STOMP::Client::Frame 3 "2011-09-27" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::STOMP::Client::Frame \- Frame support for Net::STOMP::Client
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Net::STOMP::Client::Frame;
\&
\&  # create a connection frame
\&  $frame = Net::STOMP::Client::Frame\->new(
\&      command => "CONNECT",
\&      headers => {
\&          login    => "guest",
\&          passcode => "guest",
\&      },
\&  );
\&
\&  # get the command
\&  $cmd = $frame\->command();
\&
\&  # set the body
\&  $frame\->body("...some data...");
\&
\&  # directly get a header field
\&  $msgid = $frame\->header("message\-id");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides an object oriented interface to manipulate \s-1STOMP\s0 frames.
.PP
A frame object has the following attributes: \f(CW\*(C`command\*(C'\fR, \f(CW\*(C`headers\*(C'\fR
and \f(CW\*(C`body\*(C'\fR. The \f(CW\*(C`headers\*(C'\fR must be a reference to a hash of header
key/value pairs. See Net::STOMP::Client::OO for more information on
the object oriented interface itself.
.SH "METHODS"
.IX Header "METHODS"
This module provides the following methods:
.IP "new([\s-1OPTIONS\s0])" 4
.IX Item "new([OPTIONS])"
return a new Net::STOMP::Client::Frame object (class method)
.IP "command([\s-1STRING\s0])" 4
.IX Item "command([STRING])"
get/set the command attribute
.IP "headers([\s-1HASHREF\s0])" 4
.IX Item "headers([HASHREF])"
get/set the headers attribute
.IP "header(\s-1NAME\s0)" 4
.IX Item "header(NAME)"
return the value associated with the given name in the header
.IP "body([\s-1STRING\s0])" 4
.IX Item "body([STRING])"
get/set the body attribute
.IP "body_reference([\s-1STRINGREF\s0])" 4
.IX Item "body_reference([STRINGREF])"
get/set the reference to the body attribute (useful to avoid string
copies when manipulating large bodies)
.IP "encode([\s-1OPTIONS\s0])" 4
.IX Item "encode([OPTIONS])"
encode the given frame and return a binary string suitable to be
written to a \s-1TCP\s0 stream (for instance)
.IP "\fIcheck()\fR" 4
.IX Item "check()"
check that the frame is well-formed, see below for more information
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
This module provides the following functions (which are \fBnot\fR exported):
.IP "decode(\s-1STRINGREF,\s0 [\s-1OPTIONS\s0])" 4
.IX Item "decode(STRINGREF, [OPTIONS])"
decode the given string reference and return a complete frame object,
if possible, 0 in case there is not enough data for a complete frame
or \f(CW\*(C`undef\*(C'\fR on error
.IP "parse(\s-1STRINGREF,\s0 [\s-1OPTIONS\s0])" 4
.IX Item "parse(STRINGREF, [OPTIONS])"
parse the given string reference and return true on complete frame, 0
on incomplete and \f(CW\*(C`undef\*(C'\fR on error; see the \*(L"\s-1FRAME PARSING\*(R"\s0 section
for more information
.SH "FRAME PARSING"
.IX Header "FRAME PARSING"
The \fIparse()\fR function can be used to parse a frame without decoding it.
.PP
It takes as input a string reference (to avoid string copies) and an
optional state (a hash reference). It parses the string to find out
where the different parts are and it updates its state (if given).
.PP
It returns 0 if the string does not hold a complete frame, \f(CW\*(C`undef\*(C'\fR on
error or a hash reference if a complete frame is present. The hash
contains the following keys:
.IP "before_len" 4
.IX Item "before_len"
the length of what is found before the frame (only newlines can appear here)
.IP "command_idx, command_len" 4
.IX Item "command_idx, command_len"
the start position and length of the command
.IP "header_idx, header_len" 4
.IX Item "header_idx, header_len"
the start position and length of the header
.IP "body_idx, body_len" 4
.IX Item "body_idx, body_len"
the start position and length of the body
.IP "after_idx, after_len" 4
.IX Item "after_idx, after_len"
the length of what is found after the frame (only newlines can appear here)
.IP "content_length" 4
.IX Item "content_length"
the value of the \*(L"content-length\*(R" header (if present)
.IP "total_len" 4
.IX Item "total_len"
the total length of the frame, including before and after parts
.PP
Here is how this could be used:
.PP
.Vb 8
\&  $data = "... read from socket or file ...";
\&  $info = Net::STOMP::Client::Frame::parse(\e$data);
\&  if ($info) {
\&      # extract interesting frame parts
\&      $command = substr($data, $info\->{command_idx}, $info\->{command_len});
\&      # remove the frame from the buffer
\&      substr($data, 0, $info\->{total_len}) = "";
\&  }
.Ve
.SH "CONTENT LENGTH"
.IX Header "CONTENT LENGTH"
The \*(L"content-length\*(R" header is special because it is used to indicate
the length of the body but also the \s-1JMS\s0 type of the message in
ActiveMQ as per <http://activemq.apache.org/stomp.html>.
.PP
If you do not supply a \*(L"content-length\*(R" header, following the protocol
recommendations, a \*(L"content-length\*(R" header will be added if the frame
has a body.
.PP
If you do supply a numerical \*(L"content-length\*(R" header, it will be used
as is. Warning: this may give unexpected results if the supplied value
does not match the body length. Use only with caution!
.PP
Finally, if you supply an empty string as the \*(L"content-length\*(R" header,
it will not be sent, even if the frame has a body. This can be used to
mark a message as being a TextMessage for ActiveMQ. Here is an example
of this:
.PP
.Vb 5
\&  $stomp\->send(
\&      "destination"    => "/queue/test",
\&      "body"           => "hello world!",
\&      "content\-length" => "",
\&  );
.Ve
.SH "ENCODING"
.IX Header "ENCODING"
The \s-1STOMP 1.0\s0 specification does not define which encoding should be
used to serialize frames. So, by default, this module assumes that
what has been given by the user or by the server is a ready-to-use
sequence of bytes and it does not perform any further encoding or
decoding.
.PP
However, for convenience, three global variables can be used to control
encoding/decoding.
.PP
If \f(CW$Net::STOMP::Client::Frame::UTF8Header\fR is set to true, the module
will use \s-1UTF\-8\s0 to encode/decode the header part of the frame.
.PP
The \s-1STOMP 1.1\s0 specification states that \s-1UTF\-8\s0 encoding should always
be used for the header. So, for \s-1STOMP 1.1\s0 connections,
\&\f(CW$Net::STOMP::Client::Frame::UTF8Header\fR defaults to true.
.PP
If \f(CW$Net::STOMP::Client::Frame::BodyEncode\fR is set to true, the module
will use the \f(CW\*(C`content\-type\*(C'\fR header to decide when and how to
encode/decode the body part of the frame.
.PP
The \s-1STOMP 1.1\s0 specification states that the \f(CW\*(C`content\-type\*(C'\fR header
defines when and how the body is encoded/decoded. So, for \s-1STOMP 1.1\s0
connections, \f(CW$Net::STOMP::Client::Frame::BodyEncode\fR defaults to true.
As a consequence, if you use \s-1STOMP 1.1\s0 and supply an already encoded
body, you should set \f(CW$Net::STOMP::Client::Frame::BodyEncode\fR to false
to prevent double encoding.
.PP
If \f(CW$Net::STOMP::Client::Frame::StrictEncode\fR is true, all
encoding/decoding operations will be stricter and will report a fatal
error when given malformed input. This is done by using the
Encode::FB_CROAK flag instead of the default Encode::FB_DEFAULT.
.PP
N.B.: Perl's standard Encode module is used for all encoding/decoding
operations.
.SH "COMPLIANCE"
.IX Header "COMPLIANCE"
\&\s-1STOMP 1.0\s0 has several ambiguities and this module does its best to
work \*(L"as expected\*(R" in these gray areas.
.PP
\&\s-1STOMP 1.1\s0 is much better specified and this module should be fully
compliant with the \s-1STOMP 1.1\s0 specification with two exceptions:
.IP "invalid encoding" 4
.IX Item "invalid encoding"
by default, this module is permissive and allows malformed encoded
data (this is the same default as the Encode module itself); to be
strict, set \f(CW$Net::STOMP::Client::Frame::StrictEncode\fR to true (as
explained above)
.IP "header keys" 4
.IX Item "header keys"
by default, this module allows only \*(L"reasonable\*(R" header keys, made of
alphanumerical characters (along with \f(CW\*(C`_\*(C'\fR, \f(CW\*(C`\-\*(C'\fR and \f(CW\*(C`.\*(C'\fR); to be able
to use any header key (like the specification allows), set
\&\f(CW$Net::STOMP::Client::Frame::HeaderNameRE\fR to \f(CW\*(C`q/[\ed\eD]+/\*(C'\fR.
.PP
So, to sum up, here is what you can add to your code to get strict
\&\s-1STOMP 1.1\s0 compliance:
.PP
.Vb 2
\&  $Net::STOMP::Client::Frame::StrictEncode = 1;
\&  $Net::STOMP::Client::Frame::HeaderNameRE = q/[\ed\eD]+/;
.Ve
.SH "FRAME CHECKING"
.IX Header "FRAME CHECKING"
Net::STOMP::Client calls the \fIcheck()\fR method for every frame about to
be sent and for every received frame.
.PP
The \fIcheck()\fR method verifies that the frame is well-formed. For
instance, it must contain a \f(CW\*(C`command\*(C'\fR made of uppercase letters.
.PP
The global variable \f(CW$Net::STOMP::Client::Frame::CheckLevel\fR controls
the amount of checking that is performed. The default value is 2.
.IP "0" 4
nothing is checked
.IP "1" 4
.IX Item "1"
.RS 4
.PD 0
.IP "\(bu" 4
.PD
the frame must have a good looking command
.IP "\(bu" 4
the header keys must be good looking and their value must be defined
.RE
.RS 4
.RE
.IP "2" 4
.IX Item "2"
.RS 4
.PD 0
.IP "\(bu" 4
.PD
the level 1 checks are performed
.IP "\(bu" 4
the frame must have a known command
.IP "\(bu" 4
the presence/absence of the body is checked; for instance, body is not
expected for a \*(L"\s-1CONNECT\*(R"\s0 frame
.IP "\(bu" 4
the presence of mandatory keys (e.g. \*(L"message-id\*(R" for a \*(L"\s-1MESSAGE\*(R"\s0
frame) is checked
.IP "\(bu" 4
for known header keys, their value must be good looking (e.g. the
\&\*(L"timestamp\*(R" value must be an integer)
.RE
.RS 4
.RE
.IP "3" 4
.IX Item "3"
.RS 4
.PD 0
.IP "\(bu" 4
.PD
the level 2 checks are performed
.IP "\(bu" 4
all header keys must be known/expected
.RE
.RS 4
.RE
.PP
A violation of any of these checks trigger an error in the \fIcheck()\fR
method.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Net::STOMP::Client::Debug,
Net::STOMP::Client::OO,
Encode.
.SH "AUTHOR"
.IX Header "AUTHOR"
Lionel Cons <http://cern.ch/lionel.cons>
.PP
Copyright \s-1CERN 2010\-2011\s0
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 898:" 4
.IX Item "Around line 898:"
Expected text after =item, not a number
.IP "Around line 912:" 4
.IX Item "Around line 912:"
Expected text after =item, not a number
.IP "Around line 941:" 4
.IX Item "Around line 941:"
Expected text after =item, not a number
