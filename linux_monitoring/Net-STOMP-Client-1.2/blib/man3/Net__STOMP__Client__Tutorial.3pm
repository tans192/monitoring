.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::STOMP::Client::Tutorial 3"
.TH Net::STOMP::Client::Tutorial 3 "2011-08-05" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::STOMP::Client::Tutorial \- Getting started with STOMP and Net::STOMP::Client
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
Here is a five-parts tutorial to get started with Net::STOMP::Client.
.PP
A basic knowledge of \s-1STOMP\s0 is required. For this, you can read:
.IP "\(bu" 4
<http://stomp.github.com/stomp\-specification\-1.1.html>
.Sp
the \s-1STOMP 1.1\s0 protocol specification
.IP "\(bu" 4
<http://fusesource.com/docs/broker/5.4/connectivity_guide/BHIJBDJH.html>
.Sp
the Fuse Message Broker \s-1STOMP\s0 Tutorial
.SH "PART 1: CONNECTING TO A BROKER"
.IX Header "PART 1: CONNECTING TO A BROKER"
Net::STOMP::Client, like similar modules under the Net::* hierarchy,
provides an object oriented interface to a network protocol.
.SS "\s-1CREATING AN OBJECT\s0"
.IX Subsection "CREATING AN OBJECT"
In order to connect to a broker, you first have to create an object. This
object will later be used to interact with the broker. When the module
creates the object, it tries to connect to the broker using either plain \s-1TCP\s0
or \s-1SSL.\s0 Nothing is done at the \s-1STOMP\s0 level.
.PP
To create the object, you of course need to specify where to connect
to. This can be done either with a single \f(CW\*(C`uri\*(C'\fR parameter:
.PP
.Vb 1
\&  $stomp = Net::STOMP::Client\->new(uri => "stomp://mybroker:6163");
.Ve
.PP
or with the pair of \f(CW\*(C`host\*(C'\fR and \f(CW\*(C`port\*(C'\fR parameters:
.PP
.Vb 4
\&  $stomp = Net::STOMP::Client\->new(
\&      host => "mybroker",
\&      port => 6163,
\&  );
.Ve
.SS "\s-1USING SSL\s0"
.IX Subsection "USING SSL"
Using \s-1SSL\s0 is more complex since more parameters have to be given. Note:
IO::Socket::SSL is used behind the scene so you can refer to its
documentation for more information. Here is how this could be done:
.PP
.Vb 10
\&  $stomp = Net::STOMP::Client\->new(
\&      uri => "stomp+ssl://mybroker:6162",
\&      sockopts => {
\&          # path of the directory containing trusted certificates
\&          SSL_ca_path   => "/etc/ssl/ca",
\&          # client certificate to present
\&          SSL_cert_file => "/etc/ssl/client\-cert.pem",
\&          # client private key
\&          SSL_key_file  => "/etc/ssl/client\-key.pem",
\&          # passphrase of the client private key
\&          SSL_passwd_cb => sub { return("secret") },
\&      },
\&  );
.Ve
.SS "\s-1GETTING PEER INFORMATION\s0"
.IX Subsection "GETTING PEER INFORMATION"
Once connected, at \s-1TCP\s0 or \s-1SSL\s0 level, you can get information about the
broker using the \f(CW\*(C`peer\*(C'\fR method. For instance:
.PP
.Vb 3
\&  $peer = $stomp\->peer();
\&  printf("connected to broker %s (IP %s), port %d\en",
\&      $peer\->host(), $peer\->addr(), $peer\->port());
.Ve
.SS "\s-1CONNECTING\s0"
.IX Subsection "CONNECTING"
After creating the broker object, you must start a \s-1STOMP\s0 session by sending
a \f(CW\*(C`CONNECT\*(C'\fR frame. This is as simple as:
.PP
.Vb 1
\&  $stomp\->connect();
.Ve
.PP
If authentication is required, you must pass extra information at this
stage. For instance with:
.PP
.Vb 4
\&  $stomp\->connect(
\&      login    => "guest",
\&      passcode => "welcome",
\&  );
.Ve
.PP
At this point, the session has been established and you can now send and/or
receive messages.
.SS "\s-1DISCONNECTING\s0"
.IX Subsection "DISCONNECTING"
When you are done with messaging, you should gracefully end the session by
sending a \f(CW\*(C`DISCONNECT\*(C'\fR frame with:
.PP
.Vb 1
\&  $stomp\->disconnect();
.Ve
.PP
Note: \s-1STOMP\s0 does not support reconnection. Once the session has been ended,
the broker object cannot be used anymore.
.SS "\s-1WRAP UP\s0"
.IX Subsection "WRAP UP"
Putting all this together, here is a complete program that simply connects,
starts and ends a session, printing information along the way.
.PP
.Vb 9
\&  use Net::STOMP::Client;
\&  $stomp = Net::STOMP::Client\->new(uri => "stomp://mybroker:6163");
\&  $peer = $stomp\->peer();
\&  printf("connected to broker %s (IP %s), port %d\en",
\&      $peer\->host(), $peer\->addr(), $peer\->port());
\&  $stomp\->connect();
\&  printf("session %s started\en", $stomp\->session());
\&  $stomp\->disconnect();
\&  printf("session ended\en");
.Ve
.SH "PART 2: SENDING MESSAGES"
.IX Header "PART 2: SENDING MESSAGES"
.SS "\s-1SENDING MESSAGES\s0"
.IX Subsection "SENDING MESSAGES"
A message is made of a header (a list of key/value pairs) and a body. Both are optional.
.PP
To send a message, you have to issue a \f(CW\*(C`SEND\*(C'\fR frame. For instance:
.PP
.Vb 6
\&  $stomp\->send(
\&      destination => "/queue/test",
\&      subject     => "this is a test",
\&      time        => time(),
\&      body        => "Hello world!\en",
\&  );
.Ve
.SS "\s-1USING RECEIPTS\s0"
.IX Subsection "USING RECEIPTS"
By default, you do not get any confirmation that the message has indeed been
received by the broker. If you want such a confirmation, you have to use
receipts. The following code snippet sends two messages with a \f(CW\*(C`receipt\*(C'\fR
header containing a pseudo-unique id and waits for matching \f(CW\*(C`RECEIPT\*(C'\fR
frames coming from the broker. This is easy because the Net::STOMP::Client
module keeps track of which receipts are expected and have not been received
yet.
.PP
.Vb 10
\&  $stomp\->send(
\&      destination => "/queue/test",
\&      body        => "Test of receipts 1...\en",
\&      receipt     => $stomp\->uuid(),
\&  );
\&  $stomp\->send(
\&      destination => "/queue/test",
\&      body        => "Test of receipts 2...\en",
\&      receipt     => $stomp\->uuid(),
\&  );
\&  # wait at most 10 seconds for all pending receipts
\&  $stomp\->wait_for_receipts(timeout => 10);
\&  # complain if some receipts are still pending
\&  die("Receipt not received!\en") if $stomp\->receipts();
.Ve
.PP
Note: all \s-1STOMP\s0 frames can carry a \f(CW\*(C`receipt\*(C'\fR header so this is not
restricted to message sending.
.SS "\s-1USING TRANSACTIONS\s0"
.IX Subsection "USING TRANSACTIONS"
In addition, you can use transactions to group the sending of several
messages so that either none or all of them get handled by the broker.
.PP
.Vb 10
\&  # create a unique transaction id
\&  $tid = $stomp\->uuid();
\&  # begin the transaction
\&  $stomp\->begin(transaction => $tid);
\&  # send two messages as part of this transaction
\&  $stomp\->send(
\&      destination => "/queue/test1",
\&      body        => "message 1",
\&      transaction => $tid,
\&  );
\&  $stomp\->send(
\&      destination => "/queue/test2",
\&      body        => "message 2",
\&      transaction => $tid,
\&  );
\&  # either abort or commit
\&  if (... something bad happened...) {
\&      # abort/rollback the transaction
\&      $stomp\->abort(transaction => $tid);
\&      # no messages have been delivered to the broker
\&  } else {
\&      # commit the transaction
\&      $stomp\->commit(transaction => $tid);
\&      # both messages have been delivered to the broker
\&  }
.Ve
.SH "PART 3: RECEIVING MESSAGES"
.IX Header "PART 3: RECEIVING MESSAGES"
.SS "\s-1USING SUBSCRIPTIONS\s0"
.IX Subsection "USING SUBSCRIPTIONS"
In order to receive frames, you first have to subscribe to one or more
destinations. This is as easy as:
.PP
.Vb 1
\&  $stomp\->subscribe(destination => "/queue/test");
.Ve
.PP
When you are done, you simply unsubscribe with:
.PP
.Vb 1
\&  $stomp\->unsubscribe(destination => "/queue/test");
.Ve
.PP
It is good practice to add an \f(CW\*(C`id\*(C'\fR header to uniquely identify the
subscription. All messages part of this subscription will have a matching
\&\f(CW\*(C`subscription\*(C'\fR header. This \f(CW\*(C`id\*(C'\fR can also be used to later unsubscribe.
For instance:
.PP
.Vb 6
\&  $stomp\->subscribe(
\&      destination => "/queue/test",
\&      id          => "my\-test\-sub",
\&  );
\&  # received messages will contain: subscription:my\-test\-sub
\&  $stomp\->unsubscribe(id => "my\-test\-sub");
.Ve
.SS "\s-1RECEIVING FRAMES\s0"
.IX Subsection "RECEIVING FRAMES"
While you are subscribed to some destinations, the broker may decide at any
time to send you \f(CW\*(C`MESSAGE\*(C'\fR frames. You can process these frames with a
simple loop:
.PP
.Vb 3
\&  while ($frame = $stomp\->wait_for_frames()) {
\&      # ... do something with the received frame ...
\&  }
.Ve
.PP
The code above is blocking and will loop forever. You can add a \f(CW\*(C`timeout\*(C'\fR
option to have a non-blocking loop:
.PP
.Vb 10
\&  while (1) {
\&      # wait at most one second for a new frame
\&      $frame = $stomp\->wait_for_frames(timeout => 1);
\&      # do what is appropriate
\&      if ($frame) {
\&          # ... do something with the received frame ...
\&      } else {
\&          # nothing received
\&      }
\&  }
.Ve
.PP
Because of the asynchronous nature of \s-1STOMP,\s0 receiving messages is a bit
tricky: you cannot know a priori which types of frames will be sent when.
For instance, you may want to send messages (with receipts) while you are
subscribed to some destinations and you may receive a \f(CW\*(C`MESSAGE\*(C'\fR frame while
you would like to wait for a <\s-1RECEIPT\s0> frame, or vice versa.
.PP
The \f(CW\*(C`wait_for_frames\*(C'\fR method described above will wait for any frame, not
only message frames. It is up to you to check that what you receive is a
\&\f(CW\*(C`MESSAGE\*(C'\fR frame or not. This can be done with something like:
.PP
.Vb 5
\&  if ($frame\->command() eq "MESSAGE") {
\&      # ... do something with the received message ...
\&  } else {
\&      # something else than a message frame
\&  }
.Ve
.SS "\s-1WRAP UP\s0"
.IX Subsection "WRAP UP"
Putting all this together, here is a complete program that receives ten
messages from to \f(CW\*(C`/queue/test\*(C'\fR:
.PP
.Vb 10
\&  use Net::STOMP::Client;
\&  $stomp = Net::STOMP::Client\->new(uri => "stomp://mybroker:6163");
\&  # the next line will be explained in the next part of the tutorial ;\-)
\&  $stomp\->message_callback(sub { return(1) });
\&  $stomp\->connect();
\&  $sid = $stomp\->uuid();
\&  $stomp\->subscribe(
\&      destination => "/queue/test",
\&      # we use a subscription id
\&      id          => $sid,
\&      # we want a receipt on our SUBSCRIBE frame
\&      receipt     => $stomp\->uuid(),
\&  );
\&  $count = 0;
\&  while ($count < 10) {
\&      $frame = $stomp\->wait_for_frames(timeout => 1);
\&      if ($frame) {
\&        if ($frame\->command() eq "MESSAGE") {
\&            $count++;
\&            printf("received message %d with id %s\en",
\&                   $count, $frame\->header("message\-id"));
\&        } else {
\&            # this will catch the RECEIPT frame
\&            printf("%s frame received\en", $frame\->command());
\&        }
\&      } else {
\&        print("waiting for messages...\en");
\&      }
\&  }
\&  $stomp\->unsubscribe(id => $sid);
\&  $stomp\->disconnect();
.Ve
.SH "PART 4: USING CALLBACKS"
.IX Header "PART 4: USING CALLBACKS"
As seen in part 3, because of the asynchronous nature of \s-1STOMP,\s0 it is a bit
tricky to properly handle all the different types of frames that can be
received.
.PP
In order to simplify this, Net::STOMP::Client supports the use of
callbacks. They are pieces of code called in well defined situations.
In fact, there are two levels of callbacks: global and local.
.SS "\s-1GLOBAL CALLBACKS\s0"
.IX Subsection "GLOBAL CALLBACKS"
Global (per command) callbacks are called each time a frame is received.
Net::STOMP::Client has default callbacks that should be sufficient for all
types of frames, except for \f(CW\*(C`MESSAGE\*(C'\fR frames. For these, it is really up to
the coder to define what he wants to do with the received messages.
.PP
Here is an example with a message callback counting the messages received:
.PP
.Vb 5
\&  $stomp\->message_callback(sub {
\&      my($self, $frame) = @_;
\&      $count++;
\&      return($self);
\&  });
.Ve
.PP
These callbacks are somehow global and it is good practice not to change
them during a session. If you do not need a global message callback, you can
supply the dummy:
.PP
.Vb 1
\&  $stomp\->message_callback(sub { return(1) });
.Ve
.PP
Here is how to re-write a simplified version of the inner part of the
receiving program of part 3 with a global callback:
.PP
.Vb 10
\&  $count = 0;
\&  sub msg_cb ($$) {
\&      my($self, $frame) = @_;
\&      $count++;
\&      printf("received message %d with id %s\en",
\&             $count, $frame\->header("message\-id"));
\&      return($self);
\&  }
\&  $stomp\->message_callback(\e&msg_cb);
\&  $stomp\->wait_for_frames() while $count < 10;
.Ve
.SS "\s-1LOCAL CALLBACKS\s0"
.IX Subsection "LOCAL CALLBACKS"
Local (per invocation) callbacks are called by the \f(CW\*(C`wait_for_frame\*(C'\fR method.
Their return value control what \f(CW\*(C`wait_for_frame\*(C'\fR does:
.IP "\(bu" 4
\&\f(CW\*(C`undef\*(C'\fR: an error occured
.IP "\(bu" 4
false: \f(CW\*(C`wait_for_frame\*(C'\fR should wait for more frames
.IP "\(bu" 4
true: \f(CW\*(C`wait_for_frame\*(C'\fR can stop and return this value
.PP
Here is how to use \f(CW\*(C`wait_for_frames\*(C'\fR with a local callback to wait until we
receive a \f(CW\*(C`MESSAGE\*(C'\fR frame that contains \*(L"quit\*(R" in the body:
.PP
.Vb 7
\&  sub msg_cb ($$) {
\&      my($self, $frame) = @_;
\&      return(0) unless $frame\->command() eq "MESSAGE";
\&      return(0) unless $frame\->body() =~ /quit/;
\&      return($frame);
\&  }
\&  $frame = $stomp\->wait_for_frames(callback => \e&msg_cb);
.Ve
.PP
As you see, you can put the logic either in the global callbacks or in the
local callbacks. The best practice is to have a single global message
callback that does not change throughout the execution of the program and to
optionally put in local callbacks what may change from one place of the
program to another.
.SS "\s-1WRAP UP\s0"
.IX Subsection "WRAP UP"
Here is how to re-write the receiving program of part 3 with a global
callback only counting the number of messages and a local callback printing
information:
.PP
.Vb 10
\&  use Net::STOMP::Client;
\&  $stomp = Net::STOMP::Client\->new(uri => "stomp://mybroker:6163");
\&  $stomp\->connect();
\&  sub msg_cb ($$) {
\&      my($self, $frame) = @_;
\&      my $cmd = $frame\->command();
\&      if ($cmd eq "MESSAGE") {
\&          printf("received message %d with id %s\en",
\&                 $count, $frame\->header("message\-id"));
\&      } else {
\&          printf("%s frame received\en", $cmd);
\&      }
\&      return($frame);
\&  }
\&  $stomp\->message_callback(sub { $count++ });
\&  $sid = $stomp\->uuid();
\&  $stomp\->subscribe(
\&      destination => "/queue/test",
\&      id          => $sid,
\&      receipt     => $stomp\->uuid(),
\&  );
\&  $count = 0;
\&  while ($count < 10) {
\&      $stomp\->wait_for_frames(
\&          callback => \e&msg_cb,
\&          timeout => 1,
\&      ) or print("waiting for messages...\en");
\&  }
\&  $stomp\->unsubscribe(id => $sid);
\&  $stomp\->disconnect();
.Ve
.SH "PART 5: ADVANCED FEATURES"
.IX Header "PART 5: ADVANCED FEATURES"
.SS "\s-1ACKNOWLEDGMENT MODES\s0"
.IX Subsection "ACKNOWLEDGMENT MODES"
Unless specified otherwise, subscriptions are made in \f(CW\*(C`auto\*(C'\fR mode, meaning
that a message is considered to be delivered by the broker as soon as it
sends the corresponding \f(CW\*(C`MESSAGE\*(C'\fR frame. The client may not receive the
frame or it could exit before processing it. This could result in message
loss.
.PP
In order to avoid message loss, one can change the subscription
acknowledgment mode to be \f(CW\*(C`client\*(C'\fR instead of \f(CW\*(C`auto\*(C'\fR. This is an option of
the \f(CW\*(C`SUBSCRIBE\*(C'\fR frame:
.PP
.Vb 4
\&  $stomp\->subscribe(
\&      destination => "/queue/test",
\&      ack         => "client",
\&  );
.Ve
.PP
In \f(CW\*(C`client\*(C'\fR mode, the client must explicitly acknowledge the messages it
has successfully processed. This is achieved by sending an \f(CW\*(C`ACK\*(C'\fR frame with
a \f(CW\*(C`message\-id\*(C'\fR header matching the one of the received message:
.PP
.Vb 1
\&  $stomp\->ack("message\-id" => $frame\->header("message\-id"));
.Ve
.PP
In fact, you can directly pass the frame that holds the received message and
Net::STOMP::Client will extract the \f(CW\*(C`message\-id\*(C'\fR for you:
.PP
.Vb 1
\&  $stomp\->ack(frame => $frame);
.Ve
.PP
Messages that have not be acknowledged by the end of the session will be
resent by the broker.
.PP
Note that \s-1STOMP 1.1\s0 also has a \f(CW\*(C`client\-individual\*(C'\fR mode. Please
consult the protocol specification for more details.
.SS "\s-1EFFICIENT I/O\s0"
.IX Subsection "EFFICIENT I/O"
The high-level methods handle one frame at a time. This can be
inefficient for small frames. For instance, the \f(CW\*(C`send\*(C'\fR method will
build a frame object, encode it and send it on the wire with at least
one call to \f(CW\*(C`syswrite\*(C'\fR, maybe for very few bytes.
.PP
The low-level methods allow you to better control this and queue
messages in memory before sending them. This way, you group data and
use I/O more efficiently.
.PP
Here is how to queue ten messages and send them in one go.
.PP
.Vb 11
\&  foreach $n (1 .. 10) {
\&      $frame = Net::STOMP::Client::Frame\->new(
\&          command => "SEND",
\&          headers => { destination => "/topic/test" },
\&          body    => "message $n",
\&      );
\&      # simply add the frame to the outgoing queue
\&      $stomp\->queue_frame($frame);
\&  }
\&  # no timeout given: block until all data has been sent
\&  $stomp\->send_data();
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
IO::Socket::SSL,
Net::STOMP::Client,
Net::STOMP::Client::Debug,
Net::STOMP::Client::Error,
Net::STOMP::Client::Frame,
Net::STOMP::Client::OO,
Net::STOMP::Client::Peer.
.SH "AUTHOR"
.IX Header "AUTHOR"
Lionel Cons <http://cern.ch/lionel.cons>
.PP
Copyright \s-1CERN 2010\-2011\s0
